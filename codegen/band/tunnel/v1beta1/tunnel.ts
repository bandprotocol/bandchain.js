/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: band/tunnel/v1beta1/tunnel.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../amino/amino";
import * as dependency_2 from "./../../../cosmos/base/v1beta1/coin";
import * as dependency_3 from "./../../../cosmos_proto/cosmos";
import * as dependency_4 from "./../../../gogoproto/gogo";
import * as dependency_5 from "./../../../google/protobuf/any";
import * as dependency_6 from "./../../feeds/v1beta1/feeds";
import * as pb_1 from "google-protobuf";
export namespace band.tunnel.v1beta1 {
    export class Tunnel extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            sequence?: number;
            route?: dependency_5.google.protobuf.Any;
            encoder?: dependency_6.band.feeds.v1beta1.Encoder;
            fee_payer?: string;
            signal_deviations?: SignalDeviation[];
            interval?: number;
            total_deposit?: dependency_2.cosmos.base.v1beta1.Coin[];
            is_active?: boolean;
            created_at?: number;
            creator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("route" in data && data.route != undefined) {
                    this.route = data.route;
                }
                if ("encoder" in data && data.encoder != undefined) {
                    this.encoder = data.encoder;
                }
                if ("fee_payer" in data && data.fee_payer != undefined) {
                    this.fee_payer = data.fee_payer;
                }
                if ("signal_deviations" in data && data.signal_deviations != undefined) {
                    this.signal_deviations = data.signal_deviations;
                }
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
                if ("total_deposit" in data && data.total_deposit != undefined) {
                    this.total_deposit = data.total_deposit;
                }
                if ("is_active" in data && data.is_active != undefined) {
                    this.is_active = data.is_active;
                }
                if ("created_at" in data && data.created_at != undefined) {
                    this.created_at = data.created_at;
                }
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get route() {
            return pb_1.Message.getWrapperField(this, dependency_5.google.protobuf.Any, 3) as dependency_5.google.protobuf.Any;
        }
        set route(value: dependency_5.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_route() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get encoder() {
            return pb_1.Message.getFieldWithDefault(this, 4, dependency_6.band.feeds.v1beta1.Encoder.ENCODER_UNSPECIFIED) as dependency_6.band.feeds.v1beta1.Encoder;
        }
        set encoder(value: dependency_6.band.feeds.v1beta1.Encoder) {
            pb_1.Message.setField(this, 4, value);
        }
        get fee_payer() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set fee_payer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get signal_deviations() {
            return pb_1.Message.getRepeatedWrapperField(this, SignalDeviation, 6) as SignalDeviation[];
        }
        set signal_deviations(value: SignalDeviation[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set interval(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get total_deposit() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 8) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set total_deposit(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get is_active() {
            return pb_1.Message.getFieldWithDefault(this, 9, false) as boolean;
        }
        set is_active(value: boolean) {
            pb_1.Message.setField(this, 9, value);
        }
        get created_at() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set created_at(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            id?: number;
            sequence?: number;
            route?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
            encoder?: dependency_6.band.feeds.v1beta1.Encoder;
            fee_payer?: string;
            signal_deviations?: ReturnType<typeof SignalDeviation.prototype.toObject>[];
            interval?: number;
            total_deposit?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            is_active?: boolean;
            created_at?: number;
            creator?: string;
        }): Tunnel {
            const message = new Tunnel({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.route != null) {
                message.route = dependency_5.google.protobuf.Any.fromObject(data.route);
            }
            if (data.encoder != null) {
                message.encoder = data.encoder;
            }
            if (data.fee_payer != null) {
                message.fee_payer = data.fee_payer;
            }
            if (data.signal_deviations != null) {
                message.signal_deviations = data.signal_deviations.map(item => SignalDeviation.fromObject(item));
            }
            if (data.interval != null) {
                message.interval = data.interval;
            }
            if (data.total_deposit != null) {
                message.total_deposit = data.total_deposit.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.is_active != null) {
                message.is_active = data.is_active;
            }
            if (data.created_at != null) {
                message.created_at = data.created_at;
            }
            if (data.creator != null) {
                message.creator = data.creator;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                sequence?: number;
                route?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
                encoder?: dependency_6.band.feeds.v1beta1.Encoder;
                fee_payer?: string;
                signal_deviations?: ReturnType<typeof SignalDeviation.prototype.toObject>[];
                interval?: number;
                total_deposit?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                is_active?: boolean;
                created_at?: number;
                creator?: string;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.route != null) {
                data.route = this.route.toObject();
            }
            if (this.encoder != null) {
                data.encoder = this.encoder;
            }
            if (this.fee_payer != null) {
                data.fee_payer = this.fee_payer;
            }
            if (this.signal_deviations != null) {
                data.signal_deviations = this.signal_deviations.map((item: SignalDeviation) => item.toObject());
            }
            if (this.interval != null) {
                data.interval = this.interval;
            }
            if (this.total_deposit != null) {
                data.total_deposit = this.total_deposit.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.is_active != null) {
                data.is_active = this.is_active;
            }
            if (this.created_at != null) {
                data.created_at = this.created_at;
            }
            if (this.creator != null) {
                data.creator = this.creator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeUint64(1, this.id);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (this.has_route)
                writer.writeMessage(3, this.route, () => this.route.serialize(writer));
            if (this.encoder != dependency_6.band.feeds.v1beta1.Encoder.ENCODER_UNSPECIFIED)
                writer.writeEnum(4, this.encoder);
            if (this.fee_payer.length)
                writer.writeString(5, this.fee_payer);
            if (this.signal_deviations.length)
                writer.writeRepeatedMessage(6, this.signal_deviations, (item: SignalDeviation) => item.serialize(writer));
            if (this.interval != 0)
                writer.writeUint64(7, this.interval);
            if (this.total_deposit.length)
                writer.writeRepeatedMessage(8, this.total_deposit, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.is_active != false)
                writer.writeBool(9, this.is_active);
            if (this.created_at != 0)
                writer.writeInt64(10, this.created_at);
            if (this.creator.length)
                writer.writeString(11, this.creator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tunnel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tunnel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    case 3:
                        reader.readMessage(message.route, () => message.route = dependency_5.google.protobuf.Any.deserialize(reader));
                        break;
                    case 4:
                        message.encoder = reader.readEnum();
                        break;
                    case 5:
                        message.fee_payer = reader.readString();
                        break;
                    case 6:
                        reader.readMessage(message.signal_deviations, () => pb_1.Message.addToRepeatedWrapperField(message, 6, SignalDeviation.deserialize(reader), SignalDeviation));
                        break;
                    case 7:
                        message.interval = reader.readUint64();
                        break;
                    case 8:
                        reader.readMessage(message.total_deposit, () => pb_1.Message.addToRepeatedWrapperField(message, 8, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    case 9:
                        message.is_active = reader.readBool();
                        break;
                    case 10:
                        message.created_at = reader.readInt64();
                        break;
                    case 11:
                        message.creator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tunnel {
            return Tunnel.deserialize(bytes);
        }
    }
    export class LatestPrices extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tunnel_id?: number;
            prices?: dependency_6.band.feeds.v1beta1.Price[];
            last_interval?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tunnel_id" in data && data.tunnel_id != undefined) {
                    this.tunnel_id = data.tunnel_id;
                }
                if ("prices" in data && data.prices != undefined) {
                    this.prices = data.prices;
                }
                if ("last_interval" in data && data.last_interval != undefined) {
                    this.last_interval = data.last_interval;
                }
            }
        }
        get tunnel_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set tunnel_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get prices() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_6.band.feeds.v1beta1.Price, 2) as dependency_6.band.feeds.v1beta1.Price[];
        }
        set prices(value: dependency_6.band.feeds.v1beta1.Price[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get last_interval() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set last_interval(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            tunnel_id?: number;
            prices?: ReturnType<typeof dependency_6.band.feeds.v1beta1.Price.prototype.toObject>[];
            last_interval?: number;
        }): LatestPrices {
            const message = new LatestPrices({});
            if (data.tunnel_id != null) {
                message.tunnel_id = data.tunnel_id;
            }
            if (data.prices != null) {
                message.prices = data.prices.map(item => dependency_6.band.feeds.v1beta1.Price.fromObject(item));
            }
            if (data.last_interval != null) {
                message.last_interval = data.last_interval;
            }
            return message;
        }
        toObject() {
            const data: {
                tunnel_id?: number;
                prices?: ReturnType<typeof dependency_6.band.feeds.v1beta1.Price.prototype.toObject>[];
                last_interval?: number;
            } = {};
            if (this.tunnel_id != null) {
                data.tunnel_id = this.tunnel_id;
            }
            if (this.prices != null) {
                data.prices = this.prices.map((item: dependency_6.band.feeds.v1beta1.Price) => item.toObject());
            }
            if (this.last_interval != null) {
                data.last_interval = this.last_interval;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tunnel_id != 0)
                writer.writeUint64(1, this.tunnel_id);
            if (this.prices.length)
                writer.writeRepeatedMessage(2, this.prices, (item: dependency_6.band.feeds.v1beta1.Price) => item.serialize(writer));
            if (this.last_interval != 0)
                writer.writeInt64(3, this.last_interval);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LatestPrices {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LatestPrices();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tunnel_id = reader.readUint64();
                        break;
                    case 2:
                        reader.readMessage(message.prices, () => pb_1.Message.addToRepeatedWrapperField(message, 2, dependency_6.band.feeds.v1beta1.Price.deserialize(reader), dependency_6.band.feeds.v1beta1.Price));
                        break;
                    case 3:
                        message.last_interval = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LatestPrices {
            return LatestPrices.deserialize(bytes);
        }
    }
    export class TotalFees extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            total_base_packet_fee?: dependency_2.cosmos.base.v1beta1.Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("total_base_packet_fee" in data && data.total_base_packet_fee != undefined) {
                    this.total_base_packet_fee = data.total_base_packet_fee;
                }
            }
        }
        get total_base_packet_fee() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 1) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set total_base_packet_fee(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            total_base_packet_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
        }): TotalFees {
            const message = new TotalFees({});
            if (data.total_base_packet_fee != null) {
                message.total_base_packet_fee = data.total_base_packet_fee.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                total_base_packet_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            } = {};
            if (this.total_base_packet_fee != null) {
                data.total_base_packet_fee = this.total_base_packet_fee.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.total_base_packet_fee.length)
                writer.writeRepeatedMessage(1, this.total_base_packet_fee, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TotalFees {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TotalFees();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.total_base_packet_fee, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TotalFees {
            return TotalFees.deserialize(bytes);
        }
    }
    export class Packet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tunnel_id?: number;
            sequence?: number;
            prices?: dependency_6.band.feeds.v1beta1.Price[];
            receipt?: dependency_5.google.protobuf.Any;
            base_fee?: dependency_2.cosmos.base.v1beta1.Coin[];
            route_fee?: dependency_2.cosmos.base.v1beta1.Coin[];
            created_at?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 5, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tunnel_id" in data && data.tunnel_id != undefined) {
                    this.tunnel_id = data.tunnel_id;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("prices" in data && data.prices != undefined) {
                    this.prices = data.prices;
                }
                if ("receipt" in data && data.receipt != undefined) {
                    this.receipt = data.receipt;
                }
                if ("base_fee" in data && data.base_fee != undefined) {
                    this.base_fee = data.base_fee;
                }
                if ("route_fee" in data && data.route_fee != undefined) {
                    this.route_fee = data.route_fee;
                }
                if ("created_at" in data && data.created_at != undefined) {
                    this.created_at = data.created_at;
                }
            }
        }
        get tunnel_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set tunnel_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get prices() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_6.band.feeds.v1beta1.Price, 3) as dependency_6.band.feeds.v1beta1.Price[];
        }
        set prices(value: dependency_6.band.feeds.v1beta1.Price[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get receipt() {
            return pb_1.Message.getWrapperField(this, dependency_5.google.protobuf.Any, 4) as dependency_5.google.protobuf.Any;
        }
        set receipt(value: dependency_5.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_receipt() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get base_fee() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 5) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set base_fee(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get route_fee() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 6) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set route_fee(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get created_at() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set created_at(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            tunnel_id?: number;
            sequence?: number;
            prices?: ReturnType<typeof dependency_6.band.feeds.v1beta1.Price.prototype.toObject>[];
            receipt?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
            base_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            route_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            created_at?: number;
        }): Packet {
            const message = new Packet({});
            if (data.tunnel_id != null) {
                message.tunnel_id = data.tunnel_id;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.prices != null) {
                message.prices = data.prices.map(item => dependency_6.band.feeds.v1beta1.Price.fromObject(item));
            }
            if (data.receipt != null) {
                message.receipt = dependency_5.google.protobuf.Any.fromObject(data.receipt);
            }
            if (data.base_fee != null) {
                message.base_fee = data.base_fee.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.route_fee != null) {
                message.route_fee = data.route_fee.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.created_at != null) {
                message.created_at = data.created_at;
            }
            return message;
        }
        toObject() {
            const data: {
                tunnel_id?: number;
                sequence?: number;
                prices?: ReturnType<typeof dependency_6.band.feeds.v1beta1.Price.prototype.toObject>[];
                receipt?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
                base_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                route_fee?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                created_at?: number;
            } = {};
            if (this.tunnel_id != null) {
                data.tunnel_id = this.tunnel_id;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.prices != null) {
                data.prices = this.prices.map((item: dependency_6.band.feeds.v1beta1.Price) => item.toObject());
            }
            if (this.receipt != null) {
                data.receipt = this.receipt.toObject();
            }
            if (this.base_fee != null) {
                data.base_fee = this.base_fee.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.route_fee != null) {
                data.route_fee = this.route_fee.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.created_at != null) {
                data.created_at = this.created_at;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tunnel_id != 0)
                writer.writeUint64(1, this.tunnel_id);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (this.prices.length)
                writer.writeRepeatedMessage(3, this.prices, (item: dependency_6.band.feeds.v1beta1.Price) => item.serialize(writer));
            if (this.has_receipt)
                writer.writeMessage(4, this.receipt, () => this.receipt.serialize(writer));
            if (this.base_fee.length)
                writer.writeRepeatedMessage(5, this.base_fee, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.route_fee.length)
                writer.writeRepeatedMessage(6, this.route_fee, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.created_at != 0)
                writer.writeInt64(7, this.created_at);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Packet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Packet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tunnel_id = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    case 3:
                        reader.readMessage(message.prices, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_6.band.feeds.v1beta1.Price.deserialize(reader), dependency_6.band.feeds.v1beta1.Price));
                        break;
                    case 4:
                        reader.readMessage(message.receipt, () => message.receipt = dependency_5.google.protobuf.Any.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.base_fee, () => pb_1.Message.addToRepeatedWrapperField(message, 5, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    case 6:
                        reader.readMessage(message.route_fee, () => pb_1.Message.addToRepeatedWrapperField(message, 6, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    case 7:
                        message.created_at = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Packet {
            return Packet.deserialize(bytes);
        }
    }
    export class Deposit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tunnel_id?: number;
            depositor?: string;
            amount?: dependency_2.cosmos.base.v1beta1.Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tunnel_id" in data && data.tunnel_id != undefined) {
                    this.tunnel_id = data.tunnel_id;
                }
                if ("depositor" in data && data.depositor != undefined) {
                    this.depositor = data.depositor;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get tunnel_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set tunnel_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get depositor() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set depositor(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 3) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set amount(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            tunnel_id?: number;
            depositor?: string;
            amount?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
        }): Deposit {
            const message = new Deposit({});
            if (data.tunnel_id != null) {
                message.tunnel_id = data.tunnel_id;
            }
            if (data.depositor != null) {
                message.depositor = data.depositor;
            }
            if (data.amount != null) {
                message.amount = data.amount.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                tunnel_id?: number;
                depositor?: string;
                amount?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            } = {};
            if (this.tunnel_id != null) {
                data.tunnel_id = this.tunnel_id;
            }
            if (this.depositor != null) {
                data.depositor = this.depositor;
            }
            if (this.amount != null) {
                data.amount = this.amount.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tunnel_id != 0)
                writer.writeUint64(1, this.tunnel_id);
            if (this.depositor.length)
                writer.writeString(2, this.depositor);
            if (this.amount.length)
                writer.writeRepeatedMessage(3, this.amount, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Deposit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Deposit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tunnel_id = reader.readUint64();
                        break;
                    case 2:
                        message.depositor = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 3, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Deposit {
            return Deposit.deserialize(bytes);
        }
    }
    export class SignalDeviation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            signal_id?: string;
            soft_deviation_bps?: number;
            hard_deviation_bps?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signal_id" in data && data.signal_id != undefined) {
                    this.signal_id = data.signal_id;
                }
                if ("soft_deviation_bps" in data && data.soft_deviation_bps != undefined) {
                    this.soft_deviation_bps = data.soft_deviation_bps;
                }
                if ("hard_deviation_bps" in data && data.hard_deviation_bps != undefined) {
                    this.hard_deviation_bps = data.hard_deviation_bps;
                }
            }
        }
        get signal_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set signal_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get soft_deviation_bps() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set soft_deviation_bps(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get hard_deviation_bps() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set hard_deviation_bps(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            signal_id?: string;
            soft_deviation_bps?: number;
            hard_deviation_bps?: number;
        }): SignalDeviation {
            const message = new SignalDeviation({});
            if (data.signal_id != null) {
                message.signal_id = data.signal_id;
            }
            if (data.soft_deviation_bps != null) {
                message.soft_deviation_bps = data.soft_deviation_bps;
            }
            if (data.hard_deviation_bps != null) {
                message.hard_deviation_bps = data.hard_deviation_bps;
            }
            return message;
        }
        toObject() {
            const data: {
                signal_id?: string;
                soft_deviation_bps?: number;
                hard_deviation_bps?: number;
            } = {};
            if (this.signal_id != null) {
                data.signal_id = this.signal_id;
            }
            if (this.soft_deviation_bps != null) {
                data.soft_deviation_bps = this.soft_deviation_bps;
            }
            if (this.hard_deviation_bps != null) {
                data.hard_deviation_bps = this.hard_deviation_bps;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signal_id.length)
                writer.writeString(1, this.signal_id);
            if (this.soft_deviation_bps != 0)
                writer.writeUint64(2, this.soft_deviation_bps);
            if (this.hard_deviation_bps != 0)
                writer.writeUint64(3, this.hard_deviation_bps);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignalDeviation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignalDeviation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.signal_id = reader.readString();
                        break;
                    case 2:
                        message.soft_deviation_bps = reader.readUint64();
                        break;
                    case 3:
                        message.hard_deviation_bps = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignalDeviation {
            return SignalDeviation.deserialize(bytes);
        }
    }
    export class TunnelSignatureOrder extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tunnel_id?: number;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tunnel_id" in data && data.tunnel_id != undefined) {
                    this.tunnel_id = data.tunnel_id;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get tunnel_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set tunnel_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            tunnel_id?: number;
            sequence?: number;
        }): TunnelSignatureOrder {
            const message = new TunnelSignatureOrder({});
            if (data.tunnel_id != null) {
                message.tunnel_id = data.tunnel_id;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                tunnel_id?: number;
                sequence?: number;
            } = {};
            if (this.tunnel_id != null) {
                data.tunnel_id = this.tunnel_id;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tunnel_id != 0)
                writer.writeUint64(1, this.tunnel_id);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TunnelSignatureOrder {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TunnelSignatureOrder();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.tunnel_id = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TunnelSignatureOrder {
            return TunnelSignatureOrder.deserialize(bytes);
        }
    }
}
