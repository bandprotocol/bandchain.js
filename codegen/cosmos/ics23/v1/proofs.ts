/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: cosmos/ics23/v1/proofs.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace cosmos.ics23.v1 {
    export enum HashOp {
        NO_HASH = 0,
        SHA256 = 1,
        SHA512 = 2,
        KECCAK256 = 3,
        RIPEMD160 = 4,
        BITCOIN = 5,
        SHA512_256 = 6,
        BLAKE2B_512 = 7,
        BLAKE2S_256 = 8,
        BLAKE3 = 9
    }
    export enum LengthOp {
        NO_PREFIX = 0,
        VAR_PROTO = 1,
        VAR_RLP = 2,
        FIXED32_BIG = 3,
        FIXED32_LITTLE = 4,
        FIXED64_BIG = 5,
        FIXED64_LITTLE = 6,
        REQUIRE_32_BYTES = 7,
        REQUIRE_64_BYTES = 8
    }
    export class ExistenceProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: Uint8Array;
            value?: Uint8Array;
            leaf?: LeafOp;
            path?: InnerOp[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("leaf" in data && data.leaf != undefined) {
                    this.leaf = data.leaf;
                }
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set key(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get leaf() {
            return pb_1.Message.getWrapperField(this, LeafOp, 3) as LeafOp;
        }
        set leaf(value: LeafOp) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_leaf() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get path() {
            return pb_1.Message.getRepeatedWrapperField(this, InnerOp, 4) as InnerOp[];
        }
        set path(value: InnerOp[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            key?: Uint8Array;
            value?: Uint8Array;
            leaf?: ReturnType<typeof LeafOp.prototype.toObject>;
            path?: ReturnType<typeof InnerOp.prototype.toObject>[];
        }): ExistenceProof {
            const message = new ExistenceProof({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.leaf != null) {
                message.leaf = LeafOp.fromObject(data.leaf);
            }
            if (data.path != null) {
                message.path = data.path.map(item => InnerOp.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                key?: Uint8Array;
                value?: Uint8Array;
                leaf?: ReturnType<typeof LeafOp.prototype.toObject>;
                path?: ReturnType<typeof InnerOp.prototype.toObject>[];
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.leaf != null) {
                data.leaf = this.leaf.toObject();
            }
            if (this.path != null) {
                data.path = this.path.map((item: InnerOp) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeBytes(1, this.key);
            if (this.value.length)
                writer.writeBytes(2, this.value);
            if (this.has_leaf)
                writer.writeMessage(3, this.leaf, () => this.leaf.serialize(writer));
            if (this.path.length)
                writer.writeRepeatedMessage(4, this.path, (item: InnerOp) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExistenceProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExistenceProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readBytes();
                        break;
                    case 2:
                        message.value = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.leaf, () => message.leaf = LeafOp.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.path, () => pb_1.Message.addToRepeatedWrapperField(message, 4, InnerOp.deserialize(reader), InnerOp));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ExistenceProof {
            return ExistenceProof.deserialize(bytes);
        }
    }
    export class NonExistenceProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: Uint8Array;
            left?: ExistenceProof;
            right?: ExistenceProof;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("left" in data && data.left != undefined) {
                    this.left = data.left;
                }
                if ("right" in data && data.right != undefined) {
                    this.right = data.right;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set key(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get left() {
            return pb_1.Message.getWrapperField(this, ExistenceProof, 2) as ExistenceProof;
        }
        set left(value: ExistenceProof) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_left() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get right() {
            return pb_1.Message.getWrapperField(this, ExistenceProof, 3) as ExistenceProof;
        }
        set right(value: ExistenceProof) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_right() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            key?: Uint8Array;
            left?: ReturnType<typeof ExistenceProof.prototype.toObject>;
            right?: ReturnType<typeof ExistenceProof.prototype.toObject>;
        }): NonExistenceProof {
            const message = new NonExistenceProof({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.left != null) {
                message.left = ExistenceProof.fromObject(data.left);
            }
            if (data.right != null) {
                message.right = ExistenceProof.fromObject(data.right);
            }
            return message;
        }
        toObject() {
            const data: {
                key?: Uint8Array;
                left?: ReturnType<typeof ExistenceProof.prototype.toObject>;
                right?: ReturnType<typeof ExistenceProof.prototype.toObject>;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.left != null) {
                data.left = this.left.toObject();
            }
            if (this.right != null) {
                data.right = this.right.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeBytes(1, this.key);
            if (this.has_left)
                writer.writeMessage(2, this.left, () => this.left.serialize(writer));
            if (this.has_right)
                writer.writeMessage(3, this.right, () => this.right.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NonExistenceProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NonExistenceProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.left, () => message.left = ExistenceProof.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.right, () => message.right = ExistenceProof.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NonExistenceProof {
            return NonExistenceProof.deserialize(bytes);
        }
    }
    export class CommitmentProof extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4]];
        constructor(data?: any[] | ({} & (({
            exist?: ExistenceProof;
            nonexist?: never;
            batch?: never;
            compressed?: never;
        } | {
            exist?: never;
            nonexist?: NonExistenceProof;
            batch?: never;
            compressed?: never;
        } | {
            exist?: never;
            nonexist?: never;
            batch?: BatchProof;
            compressed?: never;
        } | {
            exist?: never;
            nonexist?: never;
            batch?: never;
            compressed?: CompressedBatchProof;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("exist" in data && data.exist != undefined) {
                    this.exist = data.exist;
                }
                if ("nonexist" in data && data.nonexist != undefined) {
                    this.nonexist = data.nonexist;
                }
                if ("batch" in data && data.batch != undefined) {
                    this.batch = data.batch;
                }
                if ("compressed" in data && data.compressed != undefined) {
                    this.compressed = data.compressed;
                }
            }
        }
        get exist() {
            return pb_1.Message.getWrapperField(this, ExistenceProof, 1) as ExistenceProof;
        }
        set exist(value: ExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_exist() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get nonexist() {
            return pb_1.Message.getWrapperField(this, NonExistenceProof, 2) as NonExistenceProof;
        }
        set nonexist(value: NonExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_nonexist() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get batch() {
            return pb_1.Message.getWrapperField(this, BatchProof, 3) as BatchProof;
        }
        set batch(value: BatchProof) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_batch() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get compressed() {
            return pb_1.Message.getWrapperField(this, CompressedBatchProof, 4) as CompressedBatchProof;
        }
        set compressed(value: CompressedBatchProof) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_compressed() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get proof() {
            const cases: {
                [index: number]: "none" | "exist" | "nonexist" | "batch" | "compressed";
            } = {
                0: "none",
                1: "exist",
                2: "nonexist",
                3: "batch",
                4: "compressed"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
        }
        static fromObject(data: {
            exist?: ReturnType<typeof ExistenceProof.prototype.toObject>;
            nonexist?: ReturnType<typeof NonExistenceProof.prototype.toObject>;
            batch?: ReturnType<typeof BatchProof.prototype.toObject>;
            compressed?: ReturnType<typeof CompressedBatchProof.prototype.toObject>;
        }): CommitmentProof {
            const message = new CommitmentProof({});
            if (data.exist != null) {
                message.exist = ExistenceProof.fromObject(data.exist);
            }
            if (data.nonexist != null) {
                message.nonexist = NonExistenceProof.fromObject(data.nonexist);
            }
            if (data.batch != null) {
                message.batch = BatchProof.fromObject(data.batch);
            }
            if (data.compressed != null) {
                message.compressed = CompressedBatchProof.fromObject(data.compressed);
            }
            return message;
        }
        toObject() {
            const data: {
                exist?: ReturnType<typeof ExistenceProof.prototype.toObject>;
                nonexist?: ReturnType<typeof NonExistenceProof.prototype.toObject>;
                batch?: ReturnType<typeof BatchProof.prototype.toObject>;
                compressed?: ReturnType<typeof CompressedBatchProof.prototype.toObject>;
            } = {};
            if (this.exist != null) {
                data.exist = this.exist.toObject();
            }
            if (this.nonexist != null) {
                data.nonexist = this.nonexist.toObject();
            }
            if (this.batch != null) {
                data.batch = this.batch.toObject();
            }
            if (this.compressed != null) {
                data.compressed = this.compressed.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_exist)
                writer.writeMessage(1, this.exist, () => this.exist.serialize(writer));
            if (this.has_nonexist)
                writer.writeMessage(2, this.nonexist, () => this.nonexist.serialize(writer));
            if (this.has_batch)
                writer.writeMessage(3, this.batch, () => this.batch.serialize(writer));
            if (this.has_compressed)
                writer.writeMessage(4, this.compressed, () => this.compressed.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CommitmentProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CommitmentProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.exist, () => message.exist = ExistenceProof.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.nonexist, () => message.nonexist = NonExistenceProof.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.batch, () => message.batch = BatchProof.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.compressed, () => message.compressed = CompressedBatchProof.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CommitmentProof {
            return CommitmentProof.deserialize(bytes);
        }
    }
    export class LeafOp extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            hash?: HashOp;
            prehash_key?: HashOp;
            prehash_value?: HashOp;
            length?: LengthOp;
            prefix?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("prehash_key" in data && data.prehash_key != undefined) {
                    this.prehash_key = data.prehash_key;
                }
                if ("prehash_value" in data && data.prehash_value != undefined) {
                    this.prehash_value = data.prehash_value;
                }
                if ("length" in data && data.length != undefined) {
                    this.length = data.length;
                }
                if ("prefix" in data && data.prefix != undefined) {
                    this.prefix = data.prefix;
                }
            }
        }
        get hash() {
            return pb_1.Message.getFieldWithDefault(this, 1, HashOp.NO_HASH) as HashOp;
        }
        set hash(value: HashOp) {
            pb_1.Message.setField(this, 1, value);
        }
        get prehash_key() {
            return pb_1.Message.getFieldWithDefault(this, 2, HashOp.NO_HASH) as HashOp;
        }
        set prehash_key(value: HashOp) {
            pb_1.Message.setField(this, 2, value);
        }
        get prehash_value() {
            return pb_1.Message.getFieldWithDefault(this, 3, HashOp.NO_HASH) as HashOp;
        }
        set prehash_value(value: HashOp) {
            pb_1.Message.setField(this, 3, value);
        }
        get length() {
            return pb_1.Message.getFieldWithDefault(this, 4, LengthOp.NO_PREFIX) as LengthOp;
        }
        set length(value: LengthOp) {
            pb_1.Message.setField(this, 4, value);
        }
        get prefix() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set prefix(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            hash?: HashOp;
            prehash_key?: HashOp;
            prehash_value?: HashOp;
            length?: LengthOp;
            prefix?: Uint8Array;
        }): LeafOp {
            const message = new LeafOp({});
            if (data.hash != null) {
                message.hash = data.hash;
            }
            if (data.prehash_key != null) {
                message.prehash_key = data.prehash_key;
            }
            if (data.prehash_value != null) {
                message.prehash_value = data.prehash_value;
            }
            if (data.length != null) {
                message.length = data.length;
            }
            if (data.prefix != null) {
                message.prefix = data.prefix;
            }
            return message;
        }
        toObject() {
            const data: {
                hash?: HashOp;
                prehash_key?: HashOp;
                prehash_value?: HashOp;
                length?: LengthOp;
                prefix?: Uint8Array;
            } = {};
            if (this.hash != null) {
                data.hash = this.hash;
            }
            if (this.prehash_key != null) {
                data.prehash_key = this.prehash_key;
            }
            if (this.prehash_value != null) {
                data.prehash_value = this.prehash_value;
            }
            if (this.length != null) {
                data.length = this.length;
            }
            if (this.prefix != null) {
                data.prefix = this.prefix;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hash != HashOp.NO_HASH)
                writer.writeEnum(1, this.hash);
            if (this.prehash_key != HashOp.NO_HASH)
                writer.writeEnum(2, this.prehash_key);
            if (this.prehash_value != HashOp.NO_HASH)
                writer.writeEnum(3, this.prehash_value);
            if (this.length != LengthOp.NO_PREFIX)
                writer.writeEnum(4, this.length);
            if (this.prefix.length)
                writer.writeBytes(5, this.prefix);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LeafOp {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LeafOp();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hash = reader.readEnum();
                        break;
                    case 2:
                        message.prehash_key = reader.readEnum();
                        break;
                    case 3:
                        message.prehash_value = reader.readEnum();
                        break;
                    case 4:
                        message.length = reader.readEnum();
                        break;
                    case 5:
                        message.prefix = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LeafOp {
            return LeafOp.deserialize(bytes);
        }
    }
    export class InnerOp extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            hash?: HashOp;
            prefix?: Uint8Array;
            suffix?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("prefix" in data && data.prefix != undefined) {
                    this.prefix = data.prefix;
                }
                if ("suffix" in data && data.suffix != undefined) {
                    this.suffix = data.suffix;
                }
            }
        }
        get hash() {
            return pb_1.Message.getFieldWithDefault(this, 1, HashOp.NO_HASH) as HashOp;
        }
        set hash(value: HashOp) {
            pb_1.Message.setField(this, 1, value);
        }
        get prefix() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set prefix(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get suffix() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set suffix(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            hash?: HashOp;
            prefix?: Uint8Array;
            suffix?: Uint8Array;
        }): InnerOp {
            const message = new InnerOp({});
            if (data.hash != null) {
                message.hash = data.hash;
            }
            if (data.prefix != null) {
                message.prefix = data.prefix;
            }
            if (data.suffix != null) {
                message.suffix = data.suffix;
            }
            return message;
        }
        toObject() {
            const data: {
                hash?: HashOp;
                prefix?: Uint8Array;
                suffix?: Uint8Array;
            } = {};
            if (this.hash != null) {
                data.hash = this.hash;
            }
            if (this.prefix != null) {
                data.prefix = this.prefix;
            }
            if (this.suffix != null) {
                data.suffix = this.suffix;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hash != HashOp.NO_HASH)
                writer.writeEnum(1, this.hash);
            if (this.prefix.length)
                writer.writeBytes(2, this.prefix);
            if (this.suffix.length)
                writer.writeBytes(3, this.suffix);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InnerOp {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InnerOp();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hash = reader.readEnum();
                        break;
                    case 2:
                        message.prefix = reader.readBytes();
                        break;
                    case 3:
                        message.suffix = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InnerOp {
            return InnerOp.deserialize(bytes);
        }
    }
    export class ProofSpec extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            leaf_spec?: LeafOp;
            inner_spec?: InnerSpec;
            max_depth?: number;
            min_depth?: number;
            prehash_key_before_comparison?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("leaf_spec" in data && data.leaf_spec != undefined) {
                    this.leaf_spec = data.leaf_spec;
                }
                if ("inner_spec" in data && data.inner_spec != undefined) {
                    this.inner_spec = data.inner_spec;
                }
                if ("max_depth" in data && data.max_depth != undefined) {
                    this.max_depth = data.max_depth;
                }
                if ("min_depth" in data && data.min_depth != undefined) {
                    this.min_depth = data.min_depth;
                }
                if ("prehash_key_before_comparison" in data && data.prehash_key_before_comparison != undefined) {
                    this.prehash_key_before_comparison = data.prehash_key_before_comparison;
                }
            }
        }
        get leaf_spec() {
            return pb_1.Message.getWrapperField(this, LeafOp, 1) as LeafOp;
        }
        set leaf_spec(value: LeafOp) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_leaf_spec() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get inner_spec() {
            return pb_1.Message.getWrapperField(this, InnerSpec, 2) as InnerSpec;
        }
        set inner_spec(value: InnerSpec) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_inner_spec() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get max_depth() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set max_depth(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get min_depth() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set min_depth(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get prehash_key_before_comparison() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set prehash_key_before_comparison(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            leaf_spec?: ReturnType<typeof LeafOp.prototype.toObject>;
            inner_spec?: ReturnType<typeof InnerSpec.prototype.toObject>;
            max_depth?: number;
            min_depth?: number;
            prehash_key_before_comparison?: boolean;
        }): ProofSpec {
            const message = new ProofSpec({});
            if (data.leaf_spec != null) {
                message.leaf_spec = LeafOp.fromObject(data.leaf_spec);
            }
            if (data.inner_spec != null) {
                message.inner_spec = InnerSpec.fromObject(data.inner_spec);
            }
            if (data.max_depth != null) {
                message.max_depth = data.max_depth;
            }
            if (data.min_depth != null) {
                message.min_depth = data.min_depth;
            }
            if (data.prehash_key_before_comparison != null) {
                message.prehash_key_before_comparison = data.prehash_key_before_comparison;
            }
            return message;
        }
        toObject() {
            const data: {
                leaf_spec?: ReturnType<typeof LeafOp.prototype.toObject>;
                inner_spec?: ReturnType<typeof InnerSpec.prototype.toObject>;
                max_depth?: number;
                min_depth?: number;
                prehash_key_before_comparison?: boolean;
            } = {};
            if (this.leaf_spec != null) {
                data.leaf_spec = this.leaf_spec.toObject();
            }
            if (this.inner_spec != null) {
                data.inner_spec = this.inner_spec.toObject();
            }
            if (this.max_depth != null) {
                data.max_depth = this.max_depth;
            }
            if (this.min_depth != null) {
                data.min_depth = this.min_depth;
            }
            if (this.prehash_key_before_comparison != null) {
                data.prehash_key_before_comparison = this.prehash_key_before_comparison;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_leaf_spec)
                writer.writeMessage(1, this.leaf_spec, () => this.leaf_spec.serialize(writer));
            if (this.has_inner_spec)
                writer.writeMessage(2, this.inner_spec, () => this.inner_spec.serialize(writer));
            if (this.max_depth != 0)
                writer.writeInt32(3, this.max_depth);
            if (this.min_depth != 0)
                writer.writeInt32(4, this.min_depth);
            if (this.prehash_key_before_comparison != false)
                writer.writeBool(5, this.prehash_key_before_comparison);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProofSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProofSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.leaf_spec, () => message.leaf_spec = LeafOp.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.inner_spec, () => message.inner_spec = InnerSpec.deserialize(reader));
                        break;
                    case 3:
                        message.max_depth = reader.readInt32();
                        break;
                    case 4:
                        message.min_depth = reader.readInt32();
                        break;
                    case 5:
                        message.prehash_key_before_comparison = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ProofSpec {
            return ProofSpec.deserialize(bytes);
        }
    }
    export class InnerSpec extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            child_order?: number[];
            child_size?: number;
            min_prefix_length?: number;
            max_prefix_length?: number;
            empty_child?: Uint8Array;
            hash?: HashOp;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("child_order" in data && data.child_order != undefined) {
                    this.child_order = data.child_order;
                }
                if ("child_size" in data && data.child_size != undefined) {
                    this.child_size = data.child_size;
                }
                if ("min_prefix_length" in data && data.min_prefix_length != undefined) {
                    this.min_prefix_length = data.min_prefix_length;
                }
                if ("max_prefix_length" in data && data.max_prefix_length != undefined) {
                    this.max_prefix_length = data.max_prefix_length;
                }
                if ("empty_child" in data && data.empty_child != undefined) {
                    this.empty_child = data.empty_child;
                }
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
            }
        }
        get child_order() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set child_order(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get child_size() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set child_size(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get min_prefix_length() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min_prefix_length(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get max_prefix_length() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set max_prefix_length(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get empty_child() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set empty_child(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get hash() {
            return pb_1.Message.getFieldWithDefault(this, 6, HashOp.NO_HASH) as HashOp;
        }
        set hash(value: HashOp) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            child_order?: number[];
            child_size?: number;
            min_prefix_length?: number;
            max_prefix_length?: number;
            empty_child?: Uint8Array;
            hash?: HashOp;
        }): InnerSpec {
            const message = new InnerSpec({});
            if (data.child_order != null) {
                message.child_order = data.child_order;
            }
            if (data.child_size != null) {
                message.child_size = data.child_size;
            }
            if (data.min_prefix_length != null) {
                message.min_prefix_length = data.min_prefix_length;
            }
            if (data.max_prefix_length != null) {
                message.max_prefix_length = data.max_prefix_length;
            }
            if (data.empty_child != null) {
                message.empty_child = data.empty_child;
            }
            if (data.hash != null) {
                message.hash = data.hash;
            }
            return message;
        }
        toObject() {
            const data: {
                child_order?: number[];
                child_size?: number;
                min_prefix_length?: number;
                max_prefix_length?: number;
                empty_child?: Uint8Array;
                hash?: HashOp;
            } = {};
            if (this.child_order != null) {
                data.child_order = this.child_order;
            }
            if (this.child_size != null) {
                data.child_size = this.child_size;
            }
            if (this.min_prefix_length != null) {
                data.min_prefix_length = this.min_prefix_length;
            }
            if (this.max_prefix_length != null) {
                data.max_prefix_length = this.max_prefix_length;
            }
            if (this.empty_child != null) {
                data.empty_child = this.empty_child;
            }
            if (this.hash != null) {
                data.hash = this.hash;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.child_order.length)
                writer.writePackedInt32(1, this.child_order);
            if (this.child_size != 0)
                writer.writeInt32(2, this.child_size);
            if (this.min_prefix_length != 0)
                writer.writeInt32(3, this.min_prefix_length);
            if (this.max_prefix_length != 0)
                writer.writeInt32(4, this.max_prefix_length);
            if (this.empty_child.length)
                writer.writeBytes(5, this.empty_child);
            if (this.hash != HashOp.NO_HASH)
                writer.writeEnum(6, this.hash);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InnerSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InnerSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.child_order = reader.readPackedInt32();
                        break;
                    case 2:
                        message.child_size = reader.readInt32();
                        break;
                    case 3:
                        message.min_prefix_length = reader.readInt32();
                        break;
                    case 4:
                        message.max_prefix_length = reader.readInt32();
                        break;
                    case 5:
                        message.empty_child = reader.readBytes();
                        break;
                    case 6:
                        message.hash = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): InnerSpec {
            return InnerSpec.deserialize(bytes);
        }
    }
    export class BatchProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            entries?: BatchEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("entries" in data && data.entries != undefined) {
                    this.entries = data.entries;
                }
            }
        }
        get entries() {
            return pb_1.Message.getRepeatedWrapperField(this, BatchEntry, 1) as BatchEntry[];
        }
        set entries(value: BatchEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            entries?: ReturnType<typeof BatchEntry.prototype.toObject>[];
        }): BatchProof {
            const message = new BatchProof({});
            if (data.entries != null) {
                message.entries = data.entries.map(item => BatchEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                entries?: ReturnType<typeof BatchEntry.prototype.toObject>[];
            } = {};
            if (this.entries != null) {
                data.entries = this.entries.map((item: BatchEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.entries.length)
                writer.writeRepeatedMessage(1, this.entries, (item: BatchEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BatchProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BatchProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.entries, () => pb_1.Message.addToRepeatedWrapperField(message, 1, BatchEntry.deserialize(reader), BatchEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BatchProof {
            return BatchProof.deserialize(bytes);
        }
    }
    export class BatchEntry extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            exist?: ExistenceProof;
            nonexist?: never;
        } | {
            exist?: never;
            nonexist?: NonExistenceProof;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("exist" in data && data.exist != undefined) {
                    this.exist = data.exist;
                }
                if ("nonexist" in data && data.nonexist != undefined) {
                    this.nonexist = data.nonexist;
                }
            }
        }
        get exist() {
            return pb_1.Message.getWrapperField(this, ExistenceProof, 1) as ExistenceProof;
        }
        set exist(value: ExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_exist() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get nonexist() {
            return pb_1.Message.getWrapperField(this, NonExistenceProof, 2) as NonExistenceProof;
        }
        set nonexist(value: NonExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_nonexist() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get proof() {
            const cases: {
                [index: number]: "none" | "exist" | "nonexist";
            } = {
                0: "none",
                1: "exist",
                2: "nonexist"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            exist?: ReturnType<typeof ExistenceProof.prototype.toObject>;
            nonexist?: ReturnType<typeof NonExistenceProof.prototype.toObject>;
        }): BatchEntry {
            const message = new BatchEntry({});
            if (data.exist != null) {
                message.exist = ExistenceProof.fromObject(data.exist);
            }
            if (data.nonexist != null) {
                message.nonexist = NonExistenceProof.fromObject(data.nonexist);
            }
            return message;
        }
        toObject() {
            const data: {
                exist?: ReturnType<typeof ExistenceProof.prototype.toObject>;
                nonexist?: ReturnType<typeof NonExistenceProof.prototype.toObject>;
            } = {};
            if (this.exist != null) {
                data.exist = this.exist.toObject();
            }
            if (this.nonexist != null) {
                data.nonexist = this.nonexist.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_exist)
                writer.writeMessage(1, this.exist, () => this.exist.serialize(writer));
            if (this.has_nonexist)
                writer.writeMessage(2, this.nonexist, () => this.nonexist.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BatchEntry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BatchEntry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.exist, () => message.exist = ExistenceProof.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.nonexist, () => message.nonexist = NonExistenceProof.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BatchEntry {
            return BatchEntry.deserialize(bytes);
        }
    }
    export class CompressedBatchProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            entries?: CompressedBatchEntry[];
            lookup_inners?: InnerOp[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("entries" in data && data.entries != undefined) {
                    this.entries = data.entries;
                }
                if ("lookup_inners" in data && data.lookup_inners != undefined) {
                    this.lookup_inners = data.lookup_inners;
                }
            }
        }
        get entries() {
            return pb_1.Message.getRepeatedWrapperField(this, CompressedBatchEntry, 1) as CompressedBatchEntry[];
        }
        set entries(value: CompressedBatchEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get lookup_inners() {
            return pb_1.Message.getRepeatedWrapperField(this, InnerOp, 2) as InnerOp[];
        }
        set lookup_inners(value: InnerOp[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            entries?: ReturnType<typeof CompressedBatchEntry.prototype.toObject>[];
            lookup_inners?: ReturnType<typeof InnerOp.prototype.toObject>[];
        }): CompressedBatchProof {
            const message = new CompressedBatchProof({});
            if (data.entries != null) {
                message.entries = data.entries.map(item => CompressedBatchEntry.fromObject(item));
            }
            if (data.lookup_inners != null) {
                message.lookup_inners = data.lookup_inners.map(item => InnerOp.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                entries?: ReturnType<typeof CompressedBatchEntry.prototype.toObject>[];
                lookup_inners?: ReturnType<typeof InnerOp.prototype.toObject>[];
            } = {};
            if (this.entries != null) {
                data.entries = this.entries.map((item: CompressedBatchEntry) => item.toObject());
            }
            if (this.lookup_inners != null) {
                data.lookup_inners = this.lookup_inners.map((item: InnerOp) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.entries.length)
                writer.writeRepeatedMessage(1, this.entries, (item: CompressedBatchEntry) => item.serialize(writer));
            if (this.lookup_inners.length)
                writer.writeRepeatedMessage(2, this.lookup_inners, (item: InnerOp) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompressedBatchProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompressedBatchProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.entries, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CompressedBatchEntry.deserialize(reader), CompressedBatchEntry));
                        break;
                    case 2:
                        reader.readMessage(message.lookup_inners, () => pb_1.Message.addToRepeatedWrapperField(message, 2, InnerOp.deserialize(reader), InnerOp));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompressedBatchProof {
            return CompressedBatchProof.deserialize(bytes);
        }
    }
    export class CompressedBatchEntry extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            exist?: CompressedExistenceProof;
            nonexist?: never;
        } | {
            exist?: never;
            nonexist?: CompressedNonExistenceProof;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("exist" in data && data.exist != undefined) {
                    this.exist = data.exist;
                }
                if ("nonexist" in data && data.nonexist != undefined) {
                    this.nonexist = data.nonexist;
                }
            }
        }
        get exist() {
            return pb_1.Message.getWrapperField(this, CompressedExistenceProof, 1) as CompressedExistenceProof;
        }
        set exist(value: CompressedExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_exist() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get nonexist() {
            return pb_1.Message.getWrapperField(this, CompressedNonExistenceProof, 2) as CompressedNonExistenceProof;
        }
        set nonexist(value: CompressedNonExistenceProof) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_nonexist() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get proof() {
            const cases: {
                [index: number]: "none" | "exist" | "nonexist";
            } = {
                0: "none",
                1: "exist",
                2: "nonexist"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            exist?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
            nonexist?: ReturnType<typeof CompressedNonExistenceProof.prototype.toObject>;
        }): CompressedBatchEntry {
            const message = new CompressedBatchEntry({});
            if (data.exist != null) {
                message.exist = CompressedExistenceProof.fromObject(data.exist);
            }
            if (data.nonexist != null) {
                message.nonexist = CompressedNonExistenceProof.fromObject(data.nonexist);
            }
            return message;
        }
        toObject() {
            const data: {
                exist?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
                nonexist?: ReturnType<typeof CompressedNonExistenceProof.prototype.toObject>;
            } = {};
            if (this.exist != null) {
                data.exist = this.exist.toObject();
            }
            if (this.nonexist != null) {
                data.nonexist = this.nonexist.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_exist)
                writer.writeMessage(1, this.exist, () => this.exist.serialize(writer));
            if (this.has_nonexist)
                writer.writeMessage(2, this.nonexist, () => this.nonexist.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompressedBatchEntry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompressedBatchEntry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.exist, () => message.exist = CompressedExistenceProof.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.nonexist, () => message.nonexist = CompressedNonExistenceProof.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompressedBatchEntry {
            return CompressedBatchEntry.deserialize(bytes);
        }
    }
    export class CompressedExistenceProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: Uint8Array;
            value?: Uint8Array;
            leaf?: LeafOp;
            path?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("leaf" in data && data.leaf != undefined) {
                    this.leaf = data.leaf;
                }
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set key(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get leaf() {
            return pb_1.Message.getWrapperField(this, LeafOp, 3) as LeafOp;
        }
        set leaf(value: LeafOp) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_leaf() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as number[];
        }
        set path(value: number[]) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            key?: Uint8Array;
            value?: Uint8Array;
            leaf?: ReturnType<typeof LeafOp.prototype.toObject>;
            path?: number[];
        }): CompressedExistenceProof {
            const message = new CompressedExistenceProof({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.leaf != null) {
                message.leaf = LeafOp.fromObject(data.leaf);
            }
            if (data.path != null) {
                message.path = data.path;
            }
            return message;
        }
        toObject() {
            const data: {
                key?: Uint8Array;
                value?: Uint8Array;
                leaf?: ReturnType<typeof LeafOp.prototype.toObject>;
                path?: number[];
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.leaf != null) {
                data.leaf = this.leaf.toObject();
            }
            if (this.path != null) {
                data.path = this.path;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeBytes(1, this.key);
            if (this.value.length)
                writer.writeBytes(2, this.value);
            if (this.has_leaf)
                writer.writeMessage(3, this.leaf, () => this.leaf.serialize(writer));
            if (this.path.length)
                writer.writePackedInt32(4, this.path);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompressedExistenceProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompressedExistenceProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readBytes();
                        break;
                    case 2:
                        message.value = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.leaf, () => message.leaf = LeafOp.deserialize(reader));
                        break;
                    case 4:
                        message.path = reader.readPackedInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompressedExistenceProof {
            return CompressedExistenceProof.deserialize(bytes);
        }
    }
    export class CompressedNonExistenceProof extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: Uint8Array;
            left?: CompressedExistenceProof;
            right?: CompressedExistenceProof;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("left" in data && data.left != undefined) {
                    this.left = data.left;
                }
                if ("right" in data && data.right != undefined) {
                    this.right = data.right;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set key(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get left() {
            return pb_1.Message.getWrapperField(this, CompressedExistenceProof, 2) as CompressedExistenceProof;
        }
        set left(value: CompressedExistenceProof) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_left() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get right() {
            return pb_1.Message.getWrapperField(this, CompressedExistenceProof, 3) as CompressedExistenceProof;
        }
        set right(value: CompressedExistenceProof) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_right() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            key?: Uint8Array;
            left?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
            right?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
        }): CompressedNonExistenceProof {
            const message = new CompressedNonExistenceProof({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.left != null) {
                message.left = CompressedExistenceProof.fromObject(data.left);
            }
            if (data.right != null) {
                message.right = CompressedExistenceProof.fromObject(data.right);
            }
            return message;
        }
        toObject() {
            const data: {
                key?: Uint8Array;
                left?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
                right?: ReturnType<typeof CompressedExistenceProof.prototype.toObject>;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.left != null) {
                data.left = this.left.toObject();
            }
            if (this.right != null) {
                data.right = this.right.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeBytes(1, this.key);
            if (this.has_left)
                writer.writeMessage(2, this.left, () => this.left.serialize(writer));
            if (this.has_right)
                writer.writeMessage(3, this.right, () => this.right.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompressedNonExistenceProof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompressedNonExistenceProof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.left, () => message.left = CompressedExistenceProof.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.right, () => message.right = CompressedExistenceProof.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompressedNonExistenceProof {
            return CompressedNonExistenceProof.deserialize(bytes);
        }
    }
}
