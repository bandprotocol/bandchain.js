/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: cosmos/tx/v1beta1/tx.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../cosmos_proto/cosmos";
import * as dependency_2 from "./../../../amino/amino";
import * as dependency_3 from "./../../../gogoproto/gogo";
import * as dependency_4 from "./../../crypto/multisig/v1beta1/multisig";
import * as dependency_5 from "./../../base/v1beta1/coin";
import * as dependency_6 from "./../signing/v1beta1/signing";
import * as dependency_7 from "./../../../google/protobuf/any";
import * as dependency_8 from "./../../../google/protobuf/timestamp";
import * as pb_1 from "google-protobuf";
export namespace cosmos.tx.v1beta1 {
    export class Tx extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            body?: TxBody;
            auth_info?: AuthInfo;
            signatures?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
                if ("auth_info" in data && data.auth_info != undefined) {
                    this.auth_info = data.auth_info;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get body() {
            return pb_1.Message.getWrapperField(this, TxBody, 1) as TxBody;
        }
        set body(value: TxBody) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_body() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get auth_info() {
            return pb_1.Message.getWrapperField(this, AuthInfo, 2) as AuthInfo;
        }
        set auth_info(value: AuthInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_auth_info() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get signatures() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            body?: ReturnType<typeof TxBody.prototype.toObject>;
            auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
            signatures?: Uint8Array[];
        }): Tx {
            const message = new Tx({});
            if (data.body != null) {
                message.body = TxBody.fromObject(data.body);
            }
            if (data.auth_info != null) {
                message.auth_info = AuthInfo.fromObject(data.auth_info);
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            return message;
        }
        toObject() {
            const data: {
                body?: ReturnType<typeof TxBody.prototype.toObject>;
                auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
                signatures?: Uint8Array[];
            } = {};
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            if (this.auth_info != null) {
                data.auth_info = this.auth_info.toObject();
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_body)
                writer.writeMessage(1, this.body, () => this.body.serialize(writer));
            if (this.has_auth_info)
                writer.writeMessage(2, this.auth_info, () => this.auth_info.serialize(writer));
            if (this.signatures.length)
                writer.writeRepeatedBytes(3, this.signatures);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tx {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tx();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.body, () => message.body = TxBody.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.auth_info, () => message.auth_info = AuthInfo.deserialize(reader));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tx {
            return Tx.deserialize(bytes);
        }
    }
    export class TxRaw extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            signatures?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body_bytes" in data && data.body_bytes != undefined) {
                    this.body_bytes = data.body_bytes;
                }
                if ("auth_info_bytes" in data && data.auth_info_bytes != undefined) {
                    this.auth_info_bytes = data.auth_info_bytes;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get body_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set body_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get auth_info_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set auth_info_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get signatures() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            signatures?: Uint8Array[];
        }): TxRaw {
            const message = new TxRaw({});
            if (data.body_bytes != null) {
                message.body_bytes = data.body_bytes;
            }
            if (data.auth_info_bytes != null) {
                message.auth_info_bytes = data.auth_info_bytes;
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            return message;
        }
        toObject() {
            const data: {
                body_bytes?: Uint8Array;
                auth_info_bytes?: Uint8Array;
                signatures?: Uint8Array[];
            } = {};
            if (this.body_bytes != null) {
                data.body_bytes = this.body_bytes;
            }
            if (this.auth_info_bytes != null) {
                data.auth_info_bytes = this.auth_info_bytes;
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body_bytes.length)
                writer.writeBytes(1, this.body_bytes);
            if (this.auth_info_bytes.length)
                writer.writeBytes(2, this.auth_info_bytes);
            if (this.signatures.length)
                writer.writeRepeatedBytes(3, this.signatures);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxRaw {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxRaw();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.body_bytes = reader.readBytes();
                        break;
                    case 2:
                        message.auth_info_bytes = reader.readBytes();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxRaw {
            return TxRaw.deserialize(bytes);
        }
    }
    export class SignDoc extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            chain_id?: string;
            account_number?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body_bytes" in data && data.body_bytes != undefined) {
                    this.body_bytes = data.body_bytes;
                }
                if ("auth_info_bytes" in data && data.auth_info_bytes != undefined) {
                    this.auth_info_bytes = data.auth_info_bytes;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
            }
        }
        get body_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set body_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get auth_info_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set auth_info_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get account_number() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            chain_id?: string;
            account_number?: number;
        }): SignDoc {
            const message = new SignDoc({});
            if (data.body_bytes != null) {
                message.body_bytes = data.body_bytes;
            }
            if (data.auth_info_bytes != null) {
                message.auth_info_bytes = data.auth_info_bytes;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            return message;
        }
        toObject() {
            const data: {
                body_bytes?: Uint8Array;
                auth_info_bytes?: Uint8Array;
                chain_id?: string;
                account_number?: number;
            } = {};
            if (this.body_bytes != null) {
                data.body_bytes = this.body_bytes;
            }
            if (this.auth_info_bytes != null) {
                data.auth_info_bytes = this.auth_info_bytes;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body_bytes.length)
                writer.writeBytes(1, this.body_bytes);
            if (this.auth_info_bytes.length)
                writer.writeBytes(2, this.auth_info_bytes);
            if (this.chain_id.length)
                writer.writeString(3, this.chain_id);
            if (this.account_number != 0)
                writer.writeUint64(4, this.account_number);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignDoc {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignDoc();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.body_bytes = reader.readBytes();
                        break;
                    case 2:
                        message.auth_info_bytes = reader.readBytes();
                        break;
                    case 3:
                        message.chain_id = reader.readString();
                        break;
                    case 4:
                        message.account_number = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignDoc {
            return SignDoc.deserialize(bytes);
        }
    }
    export class SignDocDirectAux extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            body_bytes?: Uint8Array;
            public_key?: dependency_7.google.protobuf.Any;
            chain_id?: string;
            account_number?: number;
            sequence?: number;
            /** @deprecated*/
            tip?: Tip;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body_bytes" in data && data.body_bytes != undefined) {
                    this.body_bytes = data.body_bytes;
                }
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("tip" in data && data.tip != undefined) {
                    this.tip = data.tip;
                }
            }
        }
        get body_bytes() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set body_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get public_key() {
            return pb_1.Message.getWrapperField(this, dependency_7.google.protobuf.Any, 2) as dependency_7.google.protobuf.Any;
        }
        set public_key(value: dependency_7.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_public_key() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get account_number() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        /** @deprecated*/
        get tip() {
            return pb_1.Message.getWrapperField(this, Tip, 6) as Tip;
        }
        /** @deprecated*/
        set tip(value: Tip) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        /** @deprecated*/
        get has_tip() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            body_bytes?: Uint8Array;
            public_key?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>;
            chain_id?: string;
            account_number?: number;
            sequence?: number;
            tip?: ReturnType<typeof Tip.prototype.toObject>;
        }): SignDocDirectAux {
            const message = new SignDocDirectAux({});
            if (data.body_bytes != null) {
                message.body_bytes = data.body_bytes;
            }
            if (data.public_key != null) {
                message.public_key = dependency_7.google.protobuf.Any.fromObject(data.public_key);
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.tip != null) {
                message.tip = Tip.fromObject(data.tip);
            }
            return message;
        }
        toObject() {
            const data: {
                body_bytes?: Uint8Array;
                public_key?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>;
                chain_id?: string;
                account_number?: number;
                sequence?: number;
                tip?: ReturnType<typeof Tip.prototype.toObject>;
            } = {};
            if (this.body_bytes != null) {
                data.body_bytes = this.body_bytes;
            }
            if (this.public_key != null) {
                data.public_key = this.public_key.toObject();
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.tip != null) {
                data.tip = this.tip.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body_bytes.length)
                writer.writeBytes(1, this.body_bytes);
            if (this.has_public_key)
                writer.writeMessage(2, this.public_key, () => this.public_key.serialize(writer));
            if (this.chain_id.length)
                writer.writeString(3, this.chain_id);
            if (this.account_number != 0)
                writer.writeUint64(4, this.account_number);
            if (this.sequence != 0)
                writer.writeUint64(5, this.sequence);
            if (this.has_tip)
                writer.writeMessage(6, this.tip, () => this.tip.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignDocDirectAux {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignDocDirectAux();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.body_bytes = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.public_key, () => message.public_key = dependency_7.google.protobuf.Any.deserialize(reader));
                        break;
                    case 3:
                        message.chain_id = reader.readString();
                        break;
                    case 4:
                        message.account_number = reader.readUint64();
                        break;
                    case 5:
                        message.sequence = reader.readUint64();
                        break;
                    case 6:
                        reader.readMessage(message.tip, () => message.tip = Tip.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignDocDirectAux {
            return SignDocDirectAux.deserialize(bytes);
        }
    }
    export class TxBody extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            messages?: dependency_7.google.protobuf.Any[];
            memo?: string;
            timeout_height?: number;
            unordered?: boolean;
            timeout_timestamp?: dependency_8.google.protobuf.Timestamp;
            extension_options?: dependency_7.google.protobuf.Any[];
            non_critical_extension_options?: dependency_7.google.protobuf.Any[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 1023, 2047], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
                if ("memo" in data && data.memo != undefined) {
                    this.memo = data.memo;
                }
                if ("timeout_height" in data && data.timeout_height != undefined) {
                    this.timeout_height = data.timeout_height;
                }
                if ("unordered" in data && data.unordered != undefined) {
                    this.unordered = data.unordered;
                }
                if ("timeout_timestamp" in data && data.timeout_timestamp != undefined) {
                    this.timeout_timestamp = data.timeout_timestamp;
                }
                if ("extension_options" in data && data.extension_options != undefined) {
                    this.extension_options = data.extension_options;
                }
                if ("non_critical_extension_options" in data && data.non_critical_extension_options != undefined) {
                    this.non_critical_extension_options = data.non_critical_extension_options;
                }
            }
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_7.google.protobuf.Any, 1) as dependency_7.google.protobuf.Any[];
        }
        set messages(value: dependency_7.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get memo() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set memo(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get timeout_height() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set timeout_height(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get unordered() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set unordered(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get timeout_timestamp() {
            return pb_1.Message.getWrapperField(this, dependency_8.google.protobuf.Timestamp, 5) as dependency_8.google.protobuf.Timestamp;
        }
        set timeout_timestamp(value: dependency_8.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_timeout_timestamp() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_7.google.protobuf.Any, 1023) as dependency_7.google.protobuf.Any[];
        }
        set extension_options(value: dependency_7.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1023, value);
        }
        get non_critical_extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_7.google.protobuf.Any, 2047) as dependency_7.google.protobuf.Any[];
        }
        set non_critical_extension_options(value: dependency_7.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2047, value);
        }
        static fromObject(data: {
            messages?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
            memo?: string;
            timeout_height?: number;
            unordered?: boolean;
            timeout_timestamp?: ReturnType<typeof dependency_8.google.protobuf.Timestamp.prototype.toObject>;
            extension_options?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
            non_critical_extension_options?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
        }): TxBody {
            const message = new TxBody({});
            if (data.messages != null) {
                message.messages = data.messages.map(item => dependency_7.google.protobuf.Any.fromObject(item));
            }
            if (data.memo != null) {
                message.memo = data.memo;
            }
            if (data.timeout_height != null) {
                message.timeout_height = data.timeout_height;
            }
            if (data.unordered != null) {
                message.unordered = data.unordered;
            }
            if (data.timeout_timestamp != null) {
                message.timeout_timestamp = dependency_8.google.protobuf.Timestamp.fromObject(data.timeout_timestamp);
            }
            if (data.extension_options != null) {
                message.extension_options = data.extension_options.map(item => dependency_7.google.protobuf.Any.fromObject(item));
            }
            if (data.non_critical_extension_options != null) {
                message.non_critical_extension_options = data.non_critical_extension_options.map(item => dependency_7.google.protobuf.Any.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                messages?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
                memo?: string;
                timeout_height?: number;
                unordered?: boolean;
                timeout_timestamp?: ReturnType<typeof dependency_8.google.protobuf.Timestamp.prototype.toObject>;
                extension_options?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
                non_critical_extension_options?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>[];
            } = {};
            if (this.messages != null) {
                data.messages = this.messages.map((item: dependency_7.google.protobuf.Any) => item.toObject());
            }
            if (this.memo != null) {
                data.memo = this.memo;
            }
            if (this.timeout_height != null) {
                data.timeout_height = this.timeout_height;
            }
            if (this.unordered != null) {
                data.unordered = this.unordered;
            }
            if (this.timeout_timestamp != null) {
                data.timeout_timestamp = this.timeout_timestamp.toObject();
            }
            if (this.extension_options != null) {
                data.extension_options = this.extension_options.map((item: dependency_7.google.protobuf.Any) => item.toObject());
            }
            if (this.non_critical_extension_options != null) {
                data.non_critical_extension_options = this.non_critical_extension_options.map((item: dependency_7.google.protobuf.Any) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.messages.length)
                writer.writeRepeatedMessage(1, this.messages, (item: dependency_7.google.protobuf.Any) => item.serialize(writer));
            if (this.memo.length)
                writer.writeString(2, this.memo);
            if (this.timeout_height != 0)
                writer.writeUint64(3, this.timeout_height);
            if (this.unordered != false)
                writer.writeBool(4, this.unordered);
            if (this.has_timeout_timestamp)
                writer.writeMessage(5, this.timeout_timestamp, () => this.timeout_timestamp.serialize(writer));
            if (this.extension_options.length)
                writer.writeRepeatedMessage(1023, this.extension_options, (item: dependency_7.google.protobuf.Any) => item.serialize(writer));
            if (this.non_critical_extension_options.length)
                writer.writeRepeatedMessage(2047, this.non_critical_extension_options, (item: dependency_7.google.protobuf.Any) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_7.google.protobuf.Any.deserialize(reader), dependency_7.google.protobuf.Any));
                        break;
                    case 2:
                        message.memo = reader.readString();
                        break;
                    case 3:
                        message.timeout_height = reader.readUint64();
                        break;
                    case 4:
                        message.unordered = reader.readBool();
                        break;
                    case 5:
                        reader.readMessage(message.timeout_timestamp, () => message.timeout_timestamp = dependency_8.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 1023:
                        reader.readMessage(message.extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 1023, dependency_7.google.protobuf.Any.deserialize(reader), dependency_7.google.protobuf.Any));
                        break;
                    case 2047:
                        reader.readMessage(message.non_critical_extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 2047, dependency_7.google.protobuf.Any.deserialize(reader), dependency_7.google.protobuf.Any));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxBody {
            return TxBody.deserialize(bytes);
        }
    }
    export class AuthInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            signer_infos?: SignerInfo[];
            fee?: Fee;
            /** @deprecated*/
            tip?: Tip;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signer_infos" in data && data.signer_infos != undefined) {
                    this.signer_infos = data.signer_infos;
                }
                if ("fee" in data && data.fee != undefined) {
                    this.fee = data.fee;
                }
                if ("tip" in data && data.tip != undefined) {
                    this.tip = data.tip;
                }
            }
        }
        get signer_infos() {
            return pb_1.Message.getRepeatedWrapperField(this, SignerInfo, 1) as SignerInfo[];
        }
        set signer_infos(value: SignerInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get fee() {
            return pb_1.Message.getWrapperField(this, Fee, 2) as Fee;
        }
        set fee(value: Fee) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_fee() {
            return pb_1.Message.getField(this, 2) != null;
        }
        /** @deprecated*/
        get tip() {
            return pb_1.Message.getWrapperField(this, Tip, 3) as Tip;
        }
        /** @deprecated*/
        set tip(value: Tip) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        /** @deprecated*/
        get has_tip() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
            fee?: ReturnType<typeof Fee.prototype.toObject>;
            tip?: ReturnType<typeof Tip.prototype.toObject>;
        }): AuthInfo {
            const message = new AuthInfo({});
            if (data.signer_infos != null) {
                message.signer_infos = data.signer_infos.map(item => SignerInfo.fromObject(item));
            }
            if (data.fee != null) {
                message.fee = Fee.fromObject(data.fee);
            }
            if (data.tip != null) {
                message.tip = Tip.fromObject(data.tip);
            }
            return message;
        }
        toObject() {
            const data: {
                signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
                fee?: ReturnType<typeof Fee.prototype.toObject>;
                tip?: ReturnType<typeof Tip.prototype.toObject>;
            } = {};
            if (this.signer_infos != null) {
                data.signer_infos = this.signer_infos.map((item: SignerInfo) => item.toObject());
            }
            if (this.fee != null) {
                data.fee = this.fee.toObject();
            }
            if (this.tip != null) {
                data.tip = this.tip.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signer_infos.length)
                writer.writeRepeatedMessage(1, this.signer_infos, (item: SignerInfo) => item.serialize(writer));
            if (this.has_fee)
                writer.writeMessage(2, this.fee, () => this.fee.serialize(writer));
            if (this.has_tip)
                writer.writeMessage(3, this.tip, () => this.tip.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuthInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AuthInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signer_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SignerInfo.deserialize(reader), SignerInfo));
                        break;
                    case 2:
                        reader.readMessage(message.fee, () => message.fee = Fee.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.tip, () => message.tip = Tip.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AuthInfo {
            return AuthInfo.deserialize(bytes);
        }
    }
    export class SignerInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            public_key?: dependency_7.google.protobuf.Any;
            mode_info?: ModeInfo;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("mode_info" in data && data.mode_info != undefined) {
                    this.mode_info = data.mode_info;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get public_key() {
            return pb_1.Message.getWrapperField(this, dependency_7.google.protobuf.Any, 1) as dependency_7.google.protobuf.Any;
        }
        set public_key(value: dependency_7.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_public_key() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get mode_info() {
            return pb_1.Message.getWrapperField(this, ModeInfo, 2) as ModeInfo;
        }
        set mode_info(value: ModeInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_mode_info() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            public_key?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>;
            mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
            sequence?: number;
        }): SignerInfo {
            const message = new SignerInfo({});
            if (data.public_key != null) {
                message.public_key = dependency_7.google.protobuf.Any.fromObject(data.public_key);
            }
            if (data.mode_info != null) {
                message.mode_info = ModeInfo.fromObject(data.mode_info);
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                public_key?: ReturnType<typeof dependency_7.google.protobuf.Any.prototype.toObject>;
                mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
                sequence?: number;
            } = {};
            if (this.public_key != null) {
                data.public_key = this.public_key.toObject();
            }
            if (this.mode_info != null) {
                data.mode_info = this.mode_info.toObject();
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_public_key)
                writer.writeMessage(1, this.public_key, () => this.public_key.serialize(writer));
            if (this.has_mode_info)
                writer.writeMessage(2, this.mode_info, () => this.mode_info.serialize(writer));
            if (this.sequence != 0)
                writer.writeUint64(3, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignerInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignerInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.public_key, () => message.public_key = dependency_7.google.protobuf.Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.mode_info, () => message.mode_info = ModeInfo.deserialize(reader));
                        break;
                    case 3:
                        message.sequence = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignerInfo {
            return SignerInfo.deserialize(bytes);
        }
    }
    export class ModeInfo extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            single?: ModeInfo.Single;
            multi?: never;
        } | {
            single?: never;
            multi?: ModeInfo.Multi;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("single" in data && data.single != undefined) {
                    this.single = data.single;
                }
                if ("multi" in data && data.multi != undefined) {
                    this.multi = data.multi;
                }
            }
        }
        get single() {
            return pb_1.Message.getWrapperField(this, ModeInfo.Single, 1) as ModeInfo.Single;
        }
        set single(value: ModeInfo.Single) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_single() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get multi() {
            return pb_1.Message.getWrapperField(this, ModeInfo.Multi, 2) as ModeInfo.Multi;
        }
        set multi(value: ModeInfo.Multi) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_multi() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get sum() {
            const cases: {
                [index: number]: "none" | "single" | "multi";
            } = {
                0: "none",
                1: "single",
                2: "multi"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            single?: ReturnType<typeof ModeInfo.Single.prototype.toObject>;
            multi?: ReturnType<typeof ModeInfo.Multi.prototype.toObject>;
        }): ModeInfo {
            const message = new ModeInfo({});
            if (data.single != null) {
                message.single = ModeInfo.Single.fromObject(data.single);
            }
            if (data.multi != null) {
                message.multi = ModeInfo.Multi.fromObject(data.multi);
            }
            return message;
        }
        toObject() {
            const data: {
                single?: ReturnType<typeof ModeInfo.Single.prototype.toObject>;
                multi?: ReturnType<typeof ModeInfo.Multi.prototype.toObject>;
            } = {};
            if (this.single != null) {
                data.single = this.single.toObject();
            }
            if (this.multi != null) {
                data.multi = this.multi.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_single)
                writer.writeMessage(1, this.single, () => this.single.serialize(writer));
            if (this.has_multi)
                writer.writeMessage(2, this.multi, () => this.multi.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ModeInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ModeInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.single, () => message.single = ModeInfo.Single.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.multi, () => message.multi = ModeInfo.Multi.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ModeInfo {
            return ModeInfo.deserialize(bytes);
        }
    }
    export namespace ModeInfo {
        export class Single extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("mode" in data && data.mode != undefined) {
                        this.mode = data.mode;
                    }
                }
            }
            get mode() {
                return pb_1.Message.getFieldWithDefault(this, 1, dependency_6.cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_UNSPECIFIED) as dependency_6.cosmos.tx.signing.v1beta1.SignMode;
            }
            set mode(value: dependency_6.cosmos.tx.signing.v1beta1.SignMode) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
            }): Single {
                const message = new Single({});
                if (data.mode != null) {
                    message.mode = data.mode;
                }
                return message;
            }
            toObject() {
                const data: {
                    mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
                } = {};
                if (this.mode != null) {
                    data.mode = this.mode;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.mode != dependency_6.cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_UNSPECIFIED)
                    writer.writeEnum(1, this.mode);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Single {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Single();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.mode = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Single {
                return Single.deserialize(bytes);
            }
        }
        export class Multi extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                bitarray?: dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray;
                mode_infos?: ModeInfo[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("bitarray" in data && data.bitarray != undefined) {
                        this.bitarray = data.bitarray;
                    }
                    if ("mode_infos" in data && data.mode_infos != undefined) {
                        this.mode_infos = data.mode_infos;
                    }
                }
            }
            get bitarray() {
                return pb_1.Message.getWrapperField(this, dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray, 1) as dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray;
            }
            set bitarray(value: dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_bitarray() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get mode_infos() {
                return pb_1.Message.getRepeatedWrapperField(this, ModeInfo, 2) as ModeInfo[];
            }
            set mode_infos(value: ModeInfo[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                bitarray?: ReturnType<typeof dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
            }): Multi {
                const message = new Multi({});
                if (data.bitarray != null) {
                    message.bitarray = dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(data.bitarray);
                }
                if (data.mode_infos != null) {
                    message.mode_infos = data.mode_infos.map(item => ModeInfo.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    bitarray?: ReturnType<typeof dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                    mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
                } = {};
                if (this.bitarray != null) {
                    data.bitarray = this.bitarray.toObject();
                }
                if (this.mode_infos != null) {
                    data.mode_infos = this.mode_infos.map((item: ModeInfo) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_bitarray)
                    writer.writeMessage(1, this.bitarray, () => this.bitarray.serialize(writer));
                if (this.mode_infos.length)
                    writer.writeRepeatedMessage(2, this.mode_infos, (item: ModeInfo) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Multi {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Multi();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.bitarray, () => message.bitarray = dependency_4.cosmos.crypto.multisig.v1beta1.CompactBitArray.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.mode_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ModeInfo.deserialize(reader), ModeInfo));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Multi {
                return Multi.deserialize(bytes);
            }
        }
    }
    export class Fee extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amount?: dependency_5.cosmos.base.v1beta1.Coin[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("gas_limit" in data && data.gas_limit != undefined) {
                    this.gas_limit = data.gas_limit;
                }
                if ("payer" in data && data.payer != undefined) {
                    this.payer = data.payer;
                }
                if ("granter" in data && data.granter != undefined) {
                    this.granter = data.granter;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_5.cosmos.base.v1beta1.Coin, 1) as dependency_5.cosmos.base.v1beta1.Coin[];
        }
        set amount(value: dependency_5.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get gas_limit() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set gas_limit(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get payer() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set payer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get granter() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set granter(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof dependency_5.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }): Fee {
            const message = new Fee({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => dependency_5.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.gas_limit != null) {
                message.gas_limit = data.gas_limit;
            }
            if (data.payer != null) {
                message.payer = data.payer;
            }
            if (data.granter != null) {
                message.granter = data.granter;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof dependency_5.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                gas_limit?: number;
                payer?: string;
                granter?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: dependency_5.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.gas_limit != null) {
                data.gas_limit = this.gas_limit;
            }
            if (this.payer != null) {
                data.payer = this.payer;
            }
            if (this.granter != null) {
                data.granter = this.granter;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount.length)
                writer.writeRepeatedMessage(1, this.amount, (item: dependency_5.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.gas_limit != 0)
                writer.writeUint64(2, this.gas_limit);
            if (this.payer.length)
                writer.writeString(3, this.payer);
            if (this.granter.length)
                writer.writeString(4, this.granter);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Fee {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Fee();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_5.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_5.cosmos.base.v1beta1.Coin));
                        break;
                    case 2:
                        message.gas_limit = reader.readUint64();
                        break;
                    case 3:
                        message.payer = reader.readString();
                        break;
                    case 4:
                        message.granter = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Fee {
            return Fee.deserialize(bytes);
        }
    }
    /** @deprecated*/
    export class Tip extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amount?: dependency_5.cosmos.base.v1beta1.Coin[];
            tipper?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("tipper" in data && data.tipper != undefined) {
                    this.tipper = data.tipper;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_5.cosmos.base.v1beta1.Coin, 1) as dependency_5.cosmos.base.v1beta1.Coin[];
        }
        set amount(value: dependency_5.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get tipper() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set tipper(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof dependency_5.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            tipper?: string;
        }): Tip {
            const message = new Tip({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => dependency_5.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.tipper != null) {
                message.tipper = data.tipper;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof dependency_5.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                tipper?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: dependency_5.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.tipper != null) {
                data.tipper = this.tipper;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount.length)
                writer.writeRepeatedMessage(1, this.amount, (item: dependency_5.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.tipper.length)
                writer.writeString(2, this.tipper);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tip {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tip();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_5.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_5.cosmos.base.v1beta1.Coin));
                        break;
                    case 2:
                        message.tipper = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tip {
            return Tip.deserialize(bytes);
        }
    }
    export class AuxSignerData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            sign_doc?: SignDocDirectAux;
            mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
            sig?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("sign_doc" in data && data.sign_doc != undefined) {
                    this.sign_doc = data.sign_doc;
                }
                if ("mode" in data && data.mode != undefined) {
                    this.mode = data.mode;
                }
                if ("sig" in data && data.sig != undefined) {
                    this.sig = data.sig;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get sign_doc() {
            return pb_1.Message.getWrapperField(this, SignDocDirectAux, 2) as SignDocDirectAux;
        }
        set sign_doc(value: SignDocDirectAux) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_sign_doc() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get mode() {
            return pb_1.Message.getFieldWithDefault(this, 3, dependency_6.cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_UNSPECIFIED) as dependency_6.cosmos.tx.signing.v1beta1.SignMode;
        }
        set mode(value: dependency_6.cosmos.tx.signing.v1beta1.SignMode) {
            pb_1.Message.setField(this, 3, value);
        }
        get sig() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set sig(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            address?: string;
            sign_doc?: ReturnType<typeof SignDocDirectAux.prototype.toObject>;
            mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
            sig?: Uint8Array;
        }): AuxSignerData {
            const message = new AuxSignerData({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.sign_doc != null) {
                message.sign_doc = SignDocDirectAux.fromObject(data.sign_doc);
            }
            if (data.mode != null) {
                message.mode = data.mode;
            }
            if (data.sig != null) {
                message.sig = data.sig;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                sign_doc?: ReturnType<typeof SignDocDirectAux.prototype.toObject>;
                mode?: dependency_6.cosmos.tx.signing.v1beta1.SignMode;
                sig?: Uint8Array;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.sign_doc != null) {
                data.sign_doc = this.sign_doc.toObject();
            }
            if (this.mode != null) {
                data.mode = this.mode;
            }
            if (this.sig != null) {
                data.sig = this.sig;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.has_sign_doc)
                writer.writeMessage(2, this.sign_doc, () => this.sign_doc.serialize(writer));
            if (this.mode != dependency_6.cosmos.tx.signing.v1beta1.SignMode.SIGN_MODE_UNSPECIFIED)
                writer.writeEnum(3, this.mode);
            if (this.sig.length)
                writer.writeBytes(4, this.sig);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuxSignerData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AuxSignerData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.sign_doc, () => message.sign_doc = SignDocDirectAux.deserialize(reader));
                        break;
                    case 3:
                        message.mode = reader.readEnum();
                        break;
                    case 4:
                        message.sig = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AuxSignerData {
            return AuxSignerData.deserialize(bytes);
        }
    }
}
